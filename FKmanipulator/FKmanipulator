#!/usr/bin/python3

import sys
import numpy as np
import sympy as sy
import math

input_list = np.empty(0)  # リスト生成用空行列

# 標準入力からデータを取得
for line in sys.stdin:
    line = line.strip()  # 改行を削除
    if line == str(''):  # 何も入力せず改行で入力終了
        break
    input1 = line.split(' ')  # echoコマンドなど横並び入力用に半角スペース区切りで行列を作成
    input_list = np.append(input_list, input1)  # 取得したデータをinput_listの末尾に入れてリスト化


mode = int(input_list[0])
DOF = int(input_list[1])  # 自由度を取得
element_num = 2  # リストの要素抽出用変数


# リストから位置ベクトルと座標変換行列を生成
# 最後の関節から見た先端までの位置ベクトル以外を生成
for i in range(1, DOF + 1):
    # 位置ベクトルを生成
    vector_p_x = float(input_list[element_num])  # リストから位置ベクトルのx成分に該当する箇所を抽出
    element_num += 1

    vector_p_y = float(input_list[element_num])  # リストから位置ベクトルのy生成に該当する箇所を抽出
    element_num += 1

    vector_p_z = float(input_list[element_num])  # リストから位置ベクトルのz成分に該当する箇所を抽出
    element_num += 1

    # x,y,z成分から位置ベクトルを生成
    exec(f"p{str(i)} = sy.Matrix(\
            [[vector_p_x],\
            [vector_p_y],\
            [vector_p_z]]\
            )"
         )


    # 座標変換行列を生成
    exec(f"theta{str(i)} = sy.symbols('theta{str(i)}')")  # 関節の回転角度の変数thetaを定義
    # 回転軸ベクトルがx方向の場合
    if input_list[element_num] == str("x"):
        exec(f"r{str(i)} = sy.Matrix(\
                [[1, 0, 0],\
                [0, sy.cos(theta{str(i)}), - sy.sin(theta{str(i)})],\
                [0, sy.sin(theta{str(i)}), sy.cos(theta{str(i)})]]\
                )"
             )

    # 回転軸ベクトルがy方向の場合
    elif input_list[element_num] == str("y"):
        exec(f"r{str(i)} = sy.Matrix(\
                [[sy.cos(theta{str(i)}), 0, sy.sin(theta{str(i)})],\
                [0, 1, 0],\
                [- sy.sin(theta{str(i)}), 0, sy.cos(theta{str(i)})]]\
                )"
             )

    # 回転軸ベクトルがz方向の場合
    elif input_list[element_num] == str("z"):
        exec(f"r{str(i)} = sy.Matrix(\
                [[sy.cos(theta{str(i)}), - sy.sin(theta{str(i)}), 0],\
                [sy.sin(theta{str(i)}), sy.cos(theta{str(i)}), 0],\
                [0, 0, 1]]\
                )"
             )

    element_num += 1


# 最後の関節から見た手先までの位置ベクトルを生成
vector_p_x = float(input_list[element_num])
element_num += 1

vector_p_y = float(input_list[element_num])
element_num += 1

vector_p_z = float(input_list[element_num])
element_num += 1

exec(f"p{str(DOF + 1)} = sy.Matrix(\
        [[vector_p_x],\
        [vector_p_y],\
        [vector_p_z]]\
        )"
     )


# 順運動学解を求める
r0 = np.eye(3)  # 根本から見た最初の関節の位置ベクトルに対する座標変換行列を定義
A = sy.zeros(3, 1)  # 順運動学解導出用変数

for j in range(0, DOF + 1):
    # 関節の位置ベクトルに座標変換行列を掛けリンクベクトルを導出
    k = j
    exec(f"B = p{str(j + 1)}")
    while k >= 0:
        exec(f"B = r{str(k)} * B")
        k -= 1
    exec(f"l{str(j)} = B")
    
    exec(f"A += l{str(j)}")  # それぞれのリンクベクトルの合計し順運動学解を導出

oPr = A
oPr_np = sy.matrix2numpy(oPr)  # printの可読性のためsympyからnumpyに変換


# 有顔ベクトルの初期値を定義
a = sy.Matrix([[1], [0], [0]])
b = sy.Matrix([[0], [1], [0]])
c = sy.Matrix([[0], [0], [1]])

# 座標変換後の有顔ベクトルを導出
p = DOF
while p >= 0:
    exec(f"a = r{str(p)} * a")
    exec(f"b = r{str(p)} * b")
    exec(f"c = r{str(p)} * c")
    p -= 1

np_a = sy.matrix2numpy(a)
np_b = sy.matrix2numpy(b)
np_c = sy.matrix2numpy(c)

ab = np.append(a, b, axis=1)
abc = np.append(ab, c, axis=1)


# モードごとの処理を定義
# モード1の場合
if mode == 1:
    print(oPr_np)  # 順運動学解を出力

# モード2の場合
elif mode == 2:
    print(abc)  # 有顔ベクトルを出力

# モード3の場合
elif mode == 3:
    print("順運動学解は: 0Pr =\n{}\n有顔ベクトルは: [a b c] =\n{}".format(oPr_np, abc))


